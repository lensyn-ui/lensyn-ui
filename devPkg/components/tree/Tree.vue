/*************************************************
* Created by zhangtao on 2018/04/10
*************************************************/
<template>
    <ul class="tree">
        <ls-tree-item v-for="item in showDatas"
                      :level="1"
                      :indent="indent"
                      :idProperty="idProperty"
                      :labelProperty="labelProperty"
                      :childProperty="childProperty"
                      :key="getItemId(item)"
                      :isEnableChecked="isEnableChecked"
                      :data="item"
                      :checkMode="checkMode"
                      :renderTreeNode="renderTreeNode"
                      @nodeEvent="handleNodeEvent">
        </ls-tree-item>
    </ul>
</template>

<script>
    import {Component, Watch} from "vue-property-decorator";
    import { mixins } from "vue-class-component";
    import Widget from "../base/Widget.vue";
    import TreeItem from "./TreeItem.vue";
    import CommonMixin from "./CommonMixin.vue";
    import { tree as TreeUtil } from "../helper/util";
    import ContextMenu from "./ContextMenu.js";

    @Component({
        name: "tree",

        components: {
            "ls-tree-item": TreeItem
        },

        props: {
            datas: {
                type: Array,
                default: () => []
            },

            isEnableActiveNode: {
                type: Boolean,
                default: false
            },

            activeNodeMode: {
                type: String,
                default: "single"
            },

            isOnlyLeafActive: {
                type: Boolean,
                default: true
            },

            store: {
                type: Object
            },

            isEnableContextMenu: {
                type: Boolean,
                default: false
            },

            isShowContextMenu: {
                type: Function,
                default: () => false
            },

            scopedSlots: {
                type: Object
            },

            isAllowShowContextMenu: {
                type: Function
            },

            contextMenuLeftOffset: {
                type: Number,
                default: 10
            },

            contextMenuTopOffset: {
                type: Number,
                default: 10
            },

            isOnlyExpandByIcon: {
                type: Boolean,
                default: false
            }
        },
        provide() {
            return {
                expandIds: this.expandIds,
                activeIds: this.activeIds,
                checkedIds: this.checkedIds,
                partCheckedIds: this.partCheckedIds
            }
        }
    })
    export default class Tree extends mixins(CommonMixin, Widget) {
        widgetName = "tree";

        treeDatas = [];
        loadDatasMap = {};
        showDatas = [];
        expandIds = [];
        activeIds = [];
        checkedIds = [];
        partCheckedIds = [];

        @Watch("datas")
        onDatasChange() {
            this.refreshTreeDatas();
        }

        mounted() {
            this.refreshTreeDatas();
        }

        getActiveDatas() {
            let datas = [];

            TreeUtil.forEachArrayTree(this.treeDatas, (item) => {
                if (this.isActiveNode(item)) {
                    datas.push(item);
                }
            });

            return datas;
        }

        expandNode(data) {
            let id = this.getItemId(data),
                node = this.findNodeById(id);

            this.expandIds.push(id);
            this.handleExpandNode(node);
            this.emitEvent({action: "expand", data, node});
        }

        filterNode(matchFn) {
            this.showDatas = TreeUtil.filterTree(this.treeDatas, matchFn);
        }

        clearTree() {
            this.expandIds.splice(0, this.expandIds.length);
            this.loadDatasMap = {};
        }

        removeNode(id) {
            let parentNode = null,
                childNode = null;

            TreeUtil.forEachArrayTree(this.treeDatas, (item, parent) => {
                if (parentNode === null) {
                    let nodeId = this.getItemId(item);
                    if (nodeId === id) {
                        parentNode = parent;
                        childNode = item;
                    }
                }
            });
            parentNode.children.splice(parentNode.children.indexOf(childNode), 1);
            this.treeDatas = this.treeDatas;
        }

        isNodeChecked(data) {
            let id = data;

            if (typeof data === "object") {
                id = this.getItemId(data);
            }

            return this.checkedIds.indexOf(id) !== -1;
        }

        isNodePartChecked(data) {
            let id = data;

            if (typeof data === "object") {
                id = this.getItemId(data);
            }

            return this.partCheckedIds.indexOf(id) !== -1;
        }

        getCheckedLeafNode() {
            let result = [];

            TreeUtil.forEachArrayTree(this.treeDatas, (data) => {
                if (this.isLeafNode(data) && this.isNodeChecked(data)) {
                    result.push(data);
                }
            })
            return result;
        }

        checkedAll() {
            for (let i = 0, j = this.datas.length; i < j; ++i) {
                this.handleCheckedNode(this.datas[i]);
            }
        }

        clearChecked() {
            if (this.checkedIds.length !== 0) {
                for (let i = 0, j = this.datas.length; i < j; ++i) {
                    this.handleUnCheckedNode(this.datas[i]);
                }
            }
        }

        setNodesBeChecked(datas) {
            for (let i = 0, j = datas.length; i < j; ++i) {
                this.setNodeBeChecked(datas[i]);
            }
        }

        setNodeBeChecked(data) {
            let id = this.getItemId(data),
                node = this.findNodeById(id);

            if (node) {
                this.handleCheckedNode(node);
            }
        }

        findNodeById(id) {
            let node = null;

            TreeUtil.forEachArrayTree(this.treeDatas, (item) => {
                if (this.getItemId(item) === id) {
                    node = item;
                }
            });

            return node;
        }

        isActiveNode(data) {
            let id = this.getItemId(data);

            return this.activeIds.indexOf(id) !== -1;
        }

        isNodeDataReady(data) {
            if (this.isBranchNode(data)) {
                let id = this.getItemId(data);

                if (this.store && !this.loadDatasMap[id]) {
                    return false;
                }
                return true;
            }
            return true;
        }

        refreshTreeDatas() {
            let datas = JSON.parse(JSON.stringify(this.datas));

            this.showDatas = this.treeDatas = datas;
        }

        handleNodeEvent({action, data, $event}) {
            switch (action) {
                case "clickNode":
                    this.handleClickNode(data);
                    break;
                case "clickCheckbox":
                    this.handleClickCheckbox(data);
                    break;
                case "clickRadio":
                    this.handleClickRadio(data);
                    break;
                case "doubleClickNode":
                    this.handleDoubleClickNode(data);
                    break;
                case "contextMenu":
                    this.handleClickContextMenu(data, $event);
                    break;
                case "clickLabel":
                    this.handleClickLabel(data);
                    break;
                case "clickExpand":
                    this.handleClickExpandIcon(data);
                    break;
                default:
                    break;
            }
        }

        handleClickContextMenu(data, $event){
            if (this.isEnableContextMenu &&
                this.scopedSlots &&
                this.scopedSlots.contextMenu &&
                this.isAllowShowContextMenu(data)) {

                $event.preventDefault();
                let contextMenu = new ContextMenu(data, this.scopedSlots.contextMenu);
                contextMenu.show({
                    x: $event.pageX + this.contextMenuLeftOffset,
                    y: $event.pageY + this.contextMenuTopOffset
                });
            }
        }

        handleDoubleClickNode(data) {
            this.emitEvent({action: "doubleClickNode", data});
        }

        handleClickRadio(data) {
            let id = this.getItemId(data);

            this.checkedIds.splice(0, 1, id);
            this.emitEvent({action: "checkedRadio", data});
        }

        handleClickCheckbox(data) {
            if (this.isNodeChecked(data)) {
                this.handleUnCheckedNode(data);
            } else {
                if (this.isNodeDataReady(data)) {
                    this.handleCheckedNode(data);
                } else {
                    this.handleExpandNode(data, () => {
                        this.handleCheckedNode(data);
                    });
                }
            }
        }

        /**
         * 取消选中节点
         * @param {object} data
         * @todo 在计算完成后再修改 checkedIds 和 partCheckedIds
         */
        handleUnCheckedNode(data) {
            let childIds = this.getNodeAndChildIds(data),
                parentNodes = this.getNodeParent(data);

            // 处理子节点
            for (let i = 0, j = childIds.length; i < j; ++i) {
                let id = childIds[i],
                    index = this.checkedIds.indexOf(id);

                if (index !== -1) {
                    this.checkedIds.splice(index, 1);
                }
            }

            // 处理父结点
            for (let i = 0, j = parentNodes.length; i < j; ++i) {
                let node = parentNodes[i],
                    nodeId = this.getItemId(node),
                    childs = this.getItemChildren(node),
                    checkedIndex = this.checkedIds.indexOf(nodeId),
                    parcheckedIndex = this.partCheckedIds.indexOf(nodeId),
                    checkedCount = 0;

                for (let k = 0, p = childs.length; k < p; ++k) {
                    let child = childs[k];

                    if (this.isNodeChecked(child) || this.isNodePartChecked(child)) {
                        checkedCount++;
                    }
                }

                if (checkedCount === 0) {
                    if (this.isNodePartChecked(node)) {
                        this.partCheckedIds.splice(parcheckedIndex, 1);
                    }
                } else if (checkedCount !== 0 && !this.isNodePartChecked(node)) {
                    this.partCheckedIds.push(nodeId);
                }

                if (checkedIndex !== -1) {
                    this.checkedIds.splice(checkedIndex, 1);
                }
            }
            this.$nextTick(() => this.emitEvent({action: "unchecked", data}));
        }

        /**
         * 选中结点
         * @param {object} data
         * @todo 在计算完成后再修改 checkedIds 和 partCheckedIds
         */
        handleCheckedNode(data) {
            let childIds = this.getNodeAndChildIds(data),
                parentNodes = this.getNodeParent(data);

            // 处理子节点
            for (let i = 0, j = childIds.length; i < j; ++i) {
                let id = childIds[i],
                    partIndex = this.partCheckedIds.indexOf(id),
                    checkedIndex = this.checkedIds.indexOf(id);

                if (partIndex !== -1) {
                    this.partCheckedIds.splice(partIndex, 1);
                }

                if (checkedIndex === -1) {
                    this.checkedIds.push(id);
                }
            }

            // 处理父级节点，id 的顺序是从下到上
            for (let i = 0, j = parentNodes.length; i < j; ++i) {
                let node = parentNodes[i],
                    nodeId = this.getItemId(node),
                    childs = this.getItemChildren(node),
                    k = 0,
                    p = childs.length;

                for (; k < p; ++k) {
                    let childId = this.getItemId(childs[k]);

                    if (this.checkedIds.indexOf(childId) === -1) {
                        break;
                    }
                }

                if (k === p) {
                    if (this.checkedIds.indexOf(nodeId) === -1) {
                        this.checkedIds.push(nodeId);
                    }
                    
                    let partIndex = this.partCheckedIds.indexOf(nodeId);

                    if (partIndex !== -1) {
                        this.partCheckedIds.splice(partIndex, 1);
                    }
                } else {
                    if (this.partCheckedIds.indexOf(nodeId) === -1) {
                        this.partCheckedIds.push(nodeId);
                    }
                }
            }
            this.$nextTick(() => this.emitEvent({action: "checked", data}));
        }

        getNodeAndChildIds(data) {
            let ids = [];

            TreeUtil.forEachTree(data, (item) => {
                let id = this.getItemId(item);

                ids.push(id);
            });

            return ids;
        }

        /**
         * 获取一个节点的所有父级结点，包括自身
         * @param {object} data
         */
        getNodeAndParent(data) {
            return TreeUtil.findArrayTreeParentPath(this.treeDatas, data, this.childProperty);
        }

        /**
         * 获取一个节点的所有父级结点
         * @param {object} data
         */
        getNodeParent(data) {
            let datas = this.getNodeAndParent(data);

            datas.shift();

            return datas;
        }

        toggleExpandBranchNode(data) {
            let id = this.getItemId(data);

            if (this.expandIds.indexOf(id) === -1) {
                this.expandNode(data);
            } else {
                this.expandIds.splice(this.expandIds.indexOf(id), 1);
                this.emitEvent({action: "collapse", data});
            }
        }

        handleClickNode(data) {

            if (this.isEnableActiveNode) {
                this.handleActiveNode(data);
            }

            if (this.isBranchNode(data) && !this.isOnlyExpandByIcon) {
                this.toggleExpandBranchNode(data);
            }
            this.emitEvent({action: "clickNode", data});
        }

        handleActiveNode(data) {
            let id = this.getItemId(data);

            if (this.activeNodeMode === "single") {
                // 如果只选择叶子结点
                if (this.isOnlyLeafActive) {
                    // 如果是叶子结点，则将当前结点替换到活动活动结点中，否则直接清空活动结点
                    if (this.isLeafNode(data)) {
                        this.activeIds.splice(0, this.activeIds.length, id);
                        this.emitEvent({action: "checkedActiveNode", data});
                    } else {
                        this.activeIds.splice(0, this.activeIds.length);
                    }
                } else {
                    this.activeIds.splice(0, this.activeIds.length, id);
                }
            } else {
                // todo
            }
        }

        handleExpandNode(data, callback) {
            if (this.store) {
                let id = this.getItemId(data);

                if (!this.loadDatasMap[id]) {
                    this.store.load(data, (datas) => {
                        data.children = datas;
                        this.loadDatasMap[id] = true;
                        if (callback) {
                            callback();
                        }
                    });
                }
            }
        }

        handleClickLabel(data) {
            this.emitEvent({action: "clickLabel", data});
        }

        handleClickExpandIcon(data) {
            if (this.isBranchNode(data) && this.isOnlyExpandByIcon) {
                this.toggleExpandBranchNode(data);
            }
            this.emitEvent({action: "clickExpandIcon", data});
        }
    };
</script>